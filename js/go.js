// Generated by CoffeeScript 1.4.0
(function() {
  var Board, Boards,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Board = (function(_super) {

    __extends(Board, _super);

    function Board() {
      return Board.__super__.constructor.apply(this, arguments);
    }

    Board.configure("size", "state");

    Board.prototype.newboard = function() {
      var num;
      return this.state = (function() {
        var _i, _ref, _results;
        _results = [];
        for (num = _i = _ref = this.size; _ref <= 0 ? _i <= 0 : _i >= 0; num = _ref <= 0 ? ++_i : --_i) {
          _results.push(Array(this.size));
        }
        return _results;
      }).call(this);
    };

    return Board;

  })(Spine.Model);

  Boards = (function(_super) {

    __extends(Boards, _super);

    Boards.prototype.el = "#board";

    Boards.prototype.space = 20;

    Boards.prototype.move = 0;

    Boards.prototype.turn = 0;

    Boards.prototype.opponent = 1;

    Boards.prototype.turncode = ["black", "white"];

    function Boards() {
      Boards.__super__.constructor.apply(this, arguments);
      this.size--;
      this.render();
      this.xcheck = [0, 0, -1, 1];
      this.ycheck = [-1, 1, 0, 0];
      this.mover.className = this.turncode[this.turn];
    }

    Boards.prototype.elements = {
      "#mover": "mover",
      "shadow": "shadow"
    };

    Boards.prototype.events = {
      "mousemove": "moving",
      "mouseout": "hide",
      "mouseover": "show",
      "click": "place"
    };

    Boards.prototype.line = function(index) {
      var element;
      element = $("<line class='vertical' />").css({
        left: index * this.space
      });
      this.append(element);
      element = $("<line class='horizontal' />").css({
        top: index * this.space
      });
      return this.append(element);
    };

    Boards.prototype.point = function(points) {
      var renderpoint, renderpoints, x, _fn, _i, _j, _len, _len1, _results;
      renderpoints = [];
      _fn = function(x, space) {
        var element, y, _j, _len1, _results;
        this.space = space;
        _results = [];
        for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
          y = points[_j];
          element = $("<dot/>").css({
            left: x * this.space,
            top: y * this.space
          });
          _results.push(renderpoints.push(element));
        }
        return _results;
      };
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        x = points[_i];
        _fn(x, this.space);
      }
      _results = [];
      for (_j = 0, _len1 = renderpoints.length; _j < _len1; _j++) {
        renderpoint = renderpoints[_j];
        _results.push(this.append(renderpoint));
      }
      return _results;
    };

    Boards.prototype.render = function() {
      var column, iter, points, _i, _len, _ref;
      this.board = new Board({
        size: this.size
      });
      this.board.newboard();
      this.dimension = this.size * this.space;
      if (this.size > 11) {
        points = [3, this.size / 2, this.size - 3];
      } else {
        points = [this.size / 2];
      }
      this.el.css({
        width: this.dimension,
        height: this.dimension
      });
      _ref = this.board.state;
      for (iter = _i = 0, _len = _ref.length; _i < _len; iter = ++_i) {
        column = _ref[iter];
        this.line(iter);
      }
      return this.point(points);
    };

    Boards.prototype.hide = function() {
      this.shadow.hide();
      this.mover.hide();
      return this.position = false;
    };

    Boards.prototype.show = function() {
      this.shadow.show();
      return this.mover.show();
    };

    Boards.prototype.moving = function() {
      var inner, offset, outer, x, y;
      offset = $(this.el).offset();
      x = event.x - offset.left + this.space / 2;
      y = event.y - offset.top + this.space / 2;
      outer = this.dimension + this.space / 2;
      inner = 0;
      if (x > outer) {
        x = outer;
      }
      if (y > outer) {
        y = outer;
      }
      if (x < inner) {
        x = inner;
      }
      if (y < inner) {
        y = inner;
      }
      this.snap = [x - x % this.space, y - y % this.space];
      this.shadow.css({
        left: this.snap[0],
        top: this.snap[1]
      });
      this.mover.css({
        left: x - this.space / 2,
        top: y - this.space / 2
      });
      this.position = [this.snap[0] / this.space, this.snap[1] / this.space];
      return $('#report').html(this.position.toString());
    };

    Boards.prototype.renderpiece = function() {
      var piece;
      piece = $("<piece/>").addClass(this.turncode[this.turn]);
      piece.css({
        left: this.snap[0],
        top: this.snap[1]
      });
      return this.append(piece);
    };

    Boards.prototype.place = function() {
      var location;
      location = this.board.state[this.position[0]][this.position[1]];
      if (location !== void 0) {
        return;
      }
      this.aggress();
      if (!this.liberty()) {
        return;
      }
      this.renderpiece();
      this.board.state[this.position[0]][this.position[1]] = this.turn;
      this.move++;
      this.turn = this.move % 2;
      this.opponent = (this.move + 1) % 2;
      return this.mover.className = this.turncode[this.turn];
    };

    Boards.prototype.aggress = function(location) {
      var iter, neighbor, x, xc, y, yc, _i, _len, _ref, _results;
      x = this.position[0];
      y = this.position[1];
      _ref = this.xcheck;
      _results = [];
      for (iter = _i = 0, _len = _ref.length; _i < _len; iter = ++_i) {
        xc = _ref[iter];
        yc = this.ycheck[iter];
        if (y + yc === -1 || y + yc === this.size || x + xc === -1 || x + xc === this.size) {
          continue;
        }
        neighbor = this.board.state[x + xc][y + yc];
        if (neighbor === this.opponent) {
          _results.push(this.liberty(this.opponent));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Boards.prototype.liberty = function(side) {
      var iter, step, structure, xc, yc, _i, _len, _ref;
      if (side == null) {
        side = this.turn;
      }
      structure = [this.position];
      step = 0;
      _ref = this.xcheck;
      for (iter = _i = 0, _len = _ref.length; _i < _len; iter = ++_i) {
        xc = _ref[iter];
        yc = this.ycheck[iter];
        if (y + yc === -1 || y + yc === this.size || x + xc === -1 || x + xc === this.size) {
          continue;
        }
      }
      return true;
    };

    return Boards;

  })(Spine.Controller);

  $(function() {
    var board;
    return board = new Boards({
      size: 19
    });
  });

}).call(this);
