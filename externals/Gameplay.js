package {	import flash.display.*;	import flash.events.*;	import flash.net.*;	import flash.utils.Timer;	import flash.external.ExternalInterface;		public class Gameplay extends Pieces	{				protected var board:Array 			= new Array(); /* Pieces as W or B */		protected var moven:Array 			= new Array(); /* Move declarations of existing pieces; also name reference */		protected var ghist:Array 			= new Array(); /* Coded string set that stores absolute move history */				protected var cumBoard:Array		= new Array(); /* Cumulative board state */ 		protected var cumMoven:Array		= new Array(); /* Cumulative moves state */		protected var moveNum:Number		= 0;		protected var turn:String;		protected var gamestatus:String;				protected var opponent:Number;		protected var oname:String;		protected var ostat:String;		protected var player_color:String;		protected var stat:String;		protected var capsblack:Number		= 0; /* Number of black pieces captured by white */		protected var capswhite:Number		= 0; /* Number of white pieces captured by black */				protected var lastmove:*			= false;		protected var movedate:*			= false;				private var Pos:Array				= new Array();				protected var samescreen:Boolean	= false;				protected var timer:Timer;		protected const DELAY:Number		= 1000;				public function StartMover():void		{			mover.addEventListener(MouseEvent.MOUSE_DOWN, MakeMove);		}				/* Prepare gamplay arrays */		protected function BoardLogic():void		{			if(board.length > 0) return;			var r:int = 0;var c:int = 0;			for (r=0;r<siz;r++) {				board.push(new Array);				moven.push(new Array);				for (c=0;c<siz;c++) {					board[r][c]/*cola!*/= 0;					moven[r][c]/*cola!*/= 0;				}			}		}				/* Just try it, asshole */		protected function MakeMove(e:MouseEvent)		{			if(turn != player_color && !samescreen) return;			Pos = [(truePos[0]-grid.x)/spc,(truePos[1]-grid.x)/spc];			ProcessMove(Pos);		}		protected function ProcessMove(Pos:Array)		{			var xa:* = Pos[0];			var ya:* = Pos[1];						var error:Boolean = false;						if(board[xa][ya]!=0) return;						board[xa][ya] = turn;			moven[xa][ya] = moveNum+1;						aggress(xa,ya);						if(vert(xa,ya,turn)==false) 			{				board[xa][ya]=0;				moven[xa][ya]=0;				return;			}						/* Below here are successful move functions */			moveNum++;			cumBoard.push(board.join());			cumMoven.push(moven.join());						var placed:Sprite = Place(Pos[0],Pos[1],turn,moveNum);			placed.name = moven[xa][ya] = moveNum;			if(turn == player_color) SendMove();			turn = (turn == B) ? W : B;			stat = (ostat == "Playing") ? H : O;			moverstate = (turn == player_color) ? turn : stat;			MoverStatus(moverstate);					}				/* Initial agression check */		protected function aggress(xa,ya):void 		{						var oppo:String 	= (turn==B)?W:B; 						var cx:Array 		= new Array(0,0,-1,1);			var cy:Array 		= new Array(-1,1,0,0);			var i:Number;						for (i=0;i<4;i++){				if(ya+cy[i] == -1 || ya+cy[i] == siz || xa+cx[i] == -1 || xa+cx[i] == siz) continue; 				var neighbor:* = board[xa+cx[i]][ya+cy[i]];								if(neighbor==oppo) {					vert(xa+cx[i],ya+cy[i],oppo);				}			}		}				/* The vertice check function */		protected function vert(xa,ya,side) 		{						var temp:String 	= (moveNum+1).toString();			var structure:Array	= new Array([xa,ya]);			var step:int		= 0;						var verts:Boolean 	= false;						var xp:Number;			var yp:Number;						var cx:Array 		= new Array(0,0,-1,1);			var cy:Array 		= new Array(-1,1,0,0);						var i:Number;			while(step<structure.length)			{				xp = structure[step][0];				yp = structure[step][1];				for (i=0;i<4;i++) {					if(yp+cy[i] == -1 || yp+cy[i] == siz || xp+cx[i] == -1 || xp+cx[i] == siz) continue; 					var neighbor:* = board[xp+cx[i]][yp+cy[i]];										if(neighbor==0) {						verts = true;						break;					} else if(neighbor==side) {						var thread:Array = [xp+cx[i],yp+cy[i]];						var fs:Boolean = true;						var cst:Number;						for(cst=0;cst<structure.length;cst++) {							if(thread.join()==structure[cst].join()) {								fs = false;break;							}						}						if(fs==true) {							structure.push(thread);						}					}				}				step++;			}						if(side!=turn && verts==false)			{				var r:Number;				for(r=0;r<structure.length;r++)				{					var xc:Number = structure[r][0];					var yc:Number = structure[r][1];										board[xc][yc]		= 0;					var cache:String 	= moven[xc][yc];					moven[xc][yc]		= 0;										//Ko check.  Not bad.					if(structure.length==1&&board.join()==cumBoard[moveNum-2]) {						verts=false;						board[xc][yc]=side;						moven[xc][yc]=cache;					} else {						pa.removeChild(pa.getChildByName(cache));						if(turn == B) {capswhite++} else {capsblack++}					}				}			}			return verts;		}				/* Start move check cycle */		protected function startMoveCheck():void		{			timer = new Timer(DELAY,3600);			timer.addEventListener(TimerEvent.TIMER, checkMove);			sender.addEventListener(Event.COMPLETE, getMove);			timer.start();		}				protected function checkMove(event:TimerEvent):void		{			packed = new URLVariables();						packed.opponent = opponent;			packed.moveNum = moveNum;			makecall("checkmove.php");		}				protected function getMove(event:Event):void		{			var loaded:Object = getvars(event);			if(loaded.moved != "false") 			{				timer.stop();				sender.removeEventListener(Event.COMPLETE, getMove);								var X:int = loaded.moved.slice(1,loaded.moved.indexOf("y"));				var Y:int = loaded.moved.slice(loaded.moved.indexOf("y")+1);								ProcessMove([X,Y]);			} 			else if (loaded.stat == "N") 			{				timer.stop();				sender.removeEventListener(Event.COMPLETE, getMove);				moverstate = O;				MoverStatus(O);			}		}				/* Send move to game table */		protected function SendMove():void 		{			packed = new URLVariables();			sender.addEventListener(Event.COMPLETE, confirmSend);						var movepass:String = "x" + Pos[0].toString() + "y" + Pos[1].toString();						packed.turn = turn;			packed.movepass = movepass;			packed.board = board.join();			packed.moven = moven.join();			packed.capsWhite = capswhite;			packed.capsBlack = capsblack;						makecall("makemove.php");		}				/* Update last move and turn boxes */		protected function confirmSend(event:Event):void 		{			sender.removeEventListener(Event.COMPLETE, confirmSend);			var loaded:Object = getvars(event);			if(loaded.turn == turn) {				startMoveCheck();			}		}	}}